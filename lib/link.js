// Generated by CoffeeScript 1.8.0
(function() {
  var Address, Identity, PeerNAT, Port, PortRouter, codecs, dgram, events, help, internal,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  help = require('./helpers');

  Address = require('./address');

  codecs = require('./link-codecs');

  dgram = require('dgram');

  events = require('events');

  internal = {
    udp4: null,
    routes: null
  };

  Identity = (function(_super) {
    __extends(Identity, _super);

    function Identity(secretKey, options) {
      var _ref;
      this.secretKey = secretKey;
      if (options == null) {
        options = {};
      }
      if (Buffer.isBuffer(this.secretKey) && this.secretKey.length === help.nacl.box.secretKeyLength) {
        this.publicKey = help.nacl(help.nacl.box.keyPair.fromSecretKey, this.secretKey).publicKey;
      } else {
        _ref = help.nacl(help.nacl.box.keyPair), this.secretKey = _ref.secretKey, this.publicKey = _ref.publicKey;
      }
      if (options["public"]) {
        this.publicPeers = {};
        this.expire = options.expire || 60 * 10;
        this["public"] = true;
      } else {
        this.publicPeers = {};
        this.expire = 0;
        this["public"] = false;
      }
      this.trustedPeers = {};
      this.nat = new PeerNAT;
      this.udp4 = dgram.createSocket('udp4');
      this.udp4.on("message", (function(_this) {
        return function(packetdata, rinfo) {
          var messageInfo, packet, source;
          packet = codecs.id.decode({
            packet: packetdata,
            identity: _this
          });
          source = new Address({
            ip: rinfo.address,
            port: rinfo.port,
            publicKey: packet.author
          });
          _this.nat.register(source);
          messageInfo = {
            address: options.stringify ? source.toString() : source,
            port: 0
          };
          return _this.emit("message", packet.contents, messageInfo);
        };
      })(this));
      this.udp4.on("listening", (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ["listening"].concat(__slice.call(args)));
        };
      })(this));
      this.udp4.on("close", (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ["close"].concat(__slice.call(args)));
        };
      })(this));
      this.udp4.on("error", (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ["error"].concat(__slice.call(args)));
        };
      })(this));
      this.udp4.bind();
      if (options.unref) {
        this.udp4.unref();
      }
    }

    Identity.prototype.send = function() {
      var address, args, buffer, callback, contents, length, offset, packet, peer, port;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length <= 3) {
        address = args[0], contents = args[1], callback = args[2];
      } else {
        buffer = args[0], offset = args[1], length = args[2], port = args[3], address = args[4], callback = args[5];
        contents = buffer.slice(offset, offset + length);
      }
      peer = Address.parse(address);
      if (!address) {
        throw new Error("Address unparsable: " + address);
      }
      if (!peer.publicKey) {
        throw new Error("Peer network address must include public key");
      }
      peer = this.nat.lookup(peer);
      packet = codecs.id.encode({
        identity: this,
        contents: contents,
        peer: peer
      });
      return this.udp4.send(packet, 0, packet.length, peer.port, peer.ip, callback);
    };

    Identity.prototype.close = function() {
      return this.udp4.close();
    };

    Identity.prototype.address = function() {
      var addr, udp4info;
      udp4info = this.udp4.address();
      return addr = new Address({
        publicKey: this.publicKey,
        ip: udp4info.address,
        port: udp4info.port
      });
    };

    return Identity;

  })(events.EventEmitter);

  PeerNAT = (function(_super) {
    __extends(PeerNAT, _super);

    function PeerNAT() {
      this.data = {};
      this.duration = 10 * 60;
    }

    PeerNAT.prototype.register = function(newAddress) {
      var index;
      if (!(newAddress instanceof Address)) {
        newAddress = Address.parse(newAddress);
      }
      index = newAddress.publicKey.toString('hex');
      if (this.data[index]) {
        clearTimeout(this.data[index].expire);
        if (!this.data[index].address.equals(newAddress)) {
          this.emit("change", this.data[index].address, newAddress);
        }
      }
      return this.data[index] = {
        address: newAddress,
        expire: setTimeout(((function(_this) {
          return function() {
            return delete _this.data[index];
          };
        })(this)), this.duration)
      };
    };

    PeerNAT.prototype.lookup = function(lookupAddress) {
      var hashname;
      hashname = Address.parse(lookupAddress).publicKey.toString('hex');
      if (this.data[hashname]) {
        return this.data[hashname].address;
      } else {
        return lookupAddress;
      }
    };

    return PeerNAT;

  })(events.EventEmitter);

  PortRouter = (function(_super) {
    __extends(PortRouter, _super);

    function PortRouter(id) {
      this.id = id;
      this.id.on("message", (function(_this) {
        return function(data, author) {
          var destinationPort, receiver;
          author.port = data.readUInt16BE(0);
          destinationPort = data.readUInt16BE(2);
          data = data.slice(4);
          receiver = _this.ports[destinationPort.toString(36)];
          if (receiver) {
            return receiver.emit("message", data, author);
          }
        };
      })(this));
      this.ports = {};
    }

    PortRouter.prototype.createSocket = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Port, [this].concat(__slice.call(args)), function(){});
    };

    return PortRouter;

  })(events.EventEmitter);

  Port = (function(_super) {
    __extends(Port, _super);

    function Port(pr, type, opts) {
      this.pr = pr;
      if (opts == null) {
        opts = {};
      }
      this.bound = false;
      this.id = this.pr.id;
    }

    Port.prototype.bind = function() {
      var address, args, callback, options, port;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.bound !== false) {
        delete this.pr.ports[this.bound.toString(36)];
        this._bound = false;
      }
      if (typeof args[0] === 'number') {
        port = args[0], address = args[1], callback = args[2];
        options = {
          port: port,
          address: address
        };
      } else if (typeof args[0] === 'object') {
        options = args[0], callback = args[1];
      } else {
        options = {
          port: parseInt(help.uniqueIndex(this.pr.ports, 2), 36)
        };
      }
      if (typeof options.port !== 'number') {
        throw new Error("Port must be a number");
      }
      if (this.pr.ports[options.port.toString(36)]) {
        throw new Error("Port not available");
      }
      this.bound = options.port;
      this.pr.ports[this.bound.toString(36)] = this;
      if (callback) {
        return setImmediate(callback);
      }
    };

    Port.prototype.send = function() {
      var address, args, buffer, callback, contents, data, length, offset, port;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length <= 4) {
        address = args[0], port = args[1], contents = args[2], callback = args[3];
      } else {
        buffer = args[0], offset = args[1], length = args[2], port = args[3], address = args[4], callback = args[5];
        contents = buffer.slice(offset, offset + length);
      }
      if (this.bound === false) {
        this.bind();
      }
      data = new Buffer(contents.length + 4);
      data.writeUInt16BE(this.bound, 0);
      data.writeUInt16BE(port, 2);
      contents.copy(data, 4);
      return this.pr.id.send(address, data, callback);
    };

    Port.prototype.close = function() {
      delete this.pr.ports[this.bound.toString(36)];
      this.bound = false;
      return this.emit("close");
    };

    Port.prototype.address = function() {
      return this.pr.id.address();
    };

    Port.prototype.setBroadcast = function(flag) {
      if (flag) {
        throw new Error("Not Implemented");
      }
    };

    Port.prototype.setTTL = function(ttl) {
      if (ttl !== 64) {
        throw new Error("Not Implemented");
      }
    };

    Port.prototype.setMulticastTTL = function() {
      throw new Error("Not Implemented");
    };

    Port.prototype.setMulticastLoopback = function() {
      throw new Error("Not Implemented");
    };

    Port.prototype.addMembership = function() {
      throw new Error("Not Implemented");
    };

    Port.prototype.dropMembership = function() {
      throw new Error("Not Implemented");
    };

    Port.prototype.unref = function() {
      throw new Error("Not Implemented");
    };

    Port.prototype.ref = function() {
      throw new Error("Not Implemented");
    };

    return Port;

  })(events.EventEmitter);

  module.exports = {
    Identity: Identity,
    PortRouter: PortRouter
  };

}).call(this);
