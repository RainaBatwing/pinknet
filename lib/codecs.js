// Generated by CoffeeScript 1.8.0
(function() {
  var address, codecs, help, msgpack, nacl, pulseCloak;

  help = require('./helpers');

  address = require('./address');

  nacl = help.nacl;

  msgpack = help.msgpack;

  address.extendMsgpack(msgpack);

  codecs = {};

  pulseCloak = function(input, nonce, destinationPublicKey) {
    var cloak, cloakByte, idx, output, _i, _len;
    cloak = help.blake(Buffer.concat([nonce, destinationPublicKey]), input.length);
    output = new Buffer(input.length);
    for (idx = _i = 0, _len = cloak.length; _i < _len; idx = ++_i) {
      cloakByte = cloak[idx];
      output[idx] = input[idx] ^ cloakByte;
    }
    return output;
  };

  codecs.pulse = {
    encode: function(_arg) {
      var ciphertext, cloakedKey, meta, network, nonce, packet, plaintext, to;
      meta = _arg.meta, network = _arg.network, to = _arg.to;
      to = address.parse(to);
      if (meta === null) {
        meta = {};
      }
      if (!to.publicKey) {
        throw new Error("cannot encode pulse to address with no publicKey");
      }
      if (typeof meta !== 'object') {
        throw new Error("meta must be an object");
      }
      nonce = help.randomBytes(nacl.box.nonceLength);
      cloakedKey = pulseCloak(network.publicKey, nonce, to.publicKey);
      plaintext = msgpack.encode(meta).slice(0);
      ciphertext = nacl(nacl.box, plaintext, nonce, to.publicKey, network.secretKey);
      packet = Buffer.concat([nonce, cloakedKey, ciphertext]);
      return packet;
    },
    decode: function(buffer, _arg) {
      var ciphertext, cloakedKey, err, meta, network, nonce, plaintext, sender, senderPublicKey;
      network = _arg.network, sender = _arg.sender;
      if (buffer.length <= nacl.box.nonceLength + nacl.box.publicKeyLength) {
        return false;
      }
      nonce = buffer.slice(0, nacl.box.nonceLength);
      cloakedKey = buffer.slice(nacl.box.nonceLength, nacl.box.nonceLength + nacl.box.publicKeyLength);
      ciphertext = buffer.slice(nacl.box.nonceLength + nacl.box.publicKeyLength);
      senderPublicKey = pulseCloak(cloakedKey, nonce, network.publicKey);
      plaintext = nacl(nacl.box.open, ciphertext, nonce, sender.publicKey, network.secretKey);
      if (plaintext === false) {
        return false;
      }
      try {
        meta = msgpack.decode(plaintext);
        if (sender.publicKey.toString('hex') !== senderPublicKey.toString('hex')) {
          sender = sender.copy();
          sender.publicKey = senderPublicKey;
        }
        return {
          meta: meta,
          sender: sender
        };
      } catch (_error) {
        err = _error;
        return false;
      }
    }
  };

  codecs.message = {
    encode: function(_arg) {
      var ciphertext, data, network, nonce, plaintext, to, type;
      to = _arg.to, type = _arg.type, data = _arg.data, network = _arg.network;
      to = address.parse(to);
      nonce = help.randomBytes(nacl.box.nonceLength);
      plaintext = msgpack.encode([type, data]).slice(0);
      ciphertext = nacl(nacl.box, plaintext, nonce, to.publicKey, network.secretKey);
      return Buffer.concat([nonce, ciphertext]);
    },
    decode: function(buffer, _arg) {
      var ciphertext, network, nonce, obj, plaintext, sender;
      network = _arg.network, sender = _arg.sender;
      if (!sender.publicKey) {
        return false;
      }
      nonce = buffer.slice(0, nacl.box.nonceLength);
      ciphertext = buffer.slice(nacl.box.nonceLength);
      plaintext = nacl(nacl.box.open, ciphertext, nonce, sender.publicKey, network.secretKey);
      if (!plaintext) {
        return false;
      }
      obj = msgpack.decode(plaintext);
      if (!(obj.length >= 2)) {
        return false;
      }
      return {
        type: obj[0],
        data: obj[1],
        sender: sender
      };
    }
  };

  module.exports = codecs;

}).call(this);
