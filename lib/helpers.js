// Generated by CoffeeScript 1.8.0
(function() {
  var base58, blake2s, crypto, helpers, key, msgpack, nacl, value,
    __slice = [].slice;

  blake2s = require('blake2s-js');

  crypto = require('crypto');

  base58 = require('bs58');

  msgpack = require('msgpack5');

  nacl = require('tweetnacl/nacl-fast');

  helpers = {
    base58: base58,
    msgpack: msgpack,
    blake: function() {
      var args, data, digestor;
      data = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      digestor = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(blake2s, args, function(){});
      digestor.update(helpers.asTempBuffer(data));
      return helpers.asBuffer(digestor.digest());
    },
    asByteArray: function(input) {
      if (Buffer.isBuffer(input)) {
        return new Uint8Array(input);
      } else {
        return input;
      }
    },
    asBuffer: function(input) {
      if (!Buffer.isBuffer(input)) {
        return new Buffer(input);
      } else {
        return input;
      }
    },
    asTempByteArray: function(input) {
      var arr;
      if (Buffer.isBuffer(input)) {
        arr = new Uint8Array(input);
        setImmediate(function() {
          return helpers.erase(out);
        });
        return arr;
      } else {
        return input;
      }
    },
    asTempBuffer: function(input) {
      var out;
      if (!Buffer.isBuffer(input)) {
        out = new Buffer(input);
        setImmediate(function() {
          return helpers.erase(out);
        });
        return out;
      } else {
        return input;
      }
    },
    randomBytes: crypto.randomBytes,
    randomID: function(octets) {
      return base58.encode(crypto.randomBytes(octets));
    },
    uniqueIndex: function(hashmap, maxlength) {
      var id, length;
      if (maxlength == null) {
        maxlength = 8;
      }
      length = 1;
      while (true) {
        id = helpers.randomID(length);
        if (hashmap[id] === void 0) {
          return id;
        }
        if (length < maxlength) {
          length += 1;
        }
      }
    },
    erase: function() {
      var arg, argidx, arrays, i, _i, _len, _results;
      arrays = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (argidx = _i = 0, _len = arrays.length; _i < _len; argidx = ++_i) {
        arg = arrays[argidx];
        if (Buffer.isBuffer(arg)) {
          _results.push(arg.fill(0, 0, arg.length));
        } else if (arg.BYTES_PER_ELEMENT != null) {
          _results.push((function() {
            var _j, _ref, _results1;
            _results1 = [];
            for (i = _j = 0, _ref = arg.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
              _results1.push(arg[i] = 0);
            }
            return _results1;
          })());
        } else {
          throw new Error("Argument " + argidx + " isn't Buffer or Typed Array. Cannot be securely erased!");
        }
      }
      return _results;
    },
    nacl: function() {
      var arg, args, callArgs, eraseList, key, method, newObj, ret, value, _i, _len;
      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      callArgs = [];
      eraseList = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (Buffer.isBuffer(arg)) {
          arg = new Uint8Array(arg);
          eraseList.push(arg);
        }
        callArgs.push(arg);
      }
      ret = method.apply(nacl, callArgs);
      if (ret.BYTES_PER_ELEMENT) {
        eraseList.push(ret);
        ret = new Buffer(ret);
      } else if (typeof ret === 'object') {
        newObj = {};
        for (key in ret) {
          value = ret[key];
          if (value.BYTES_PER_ELEMENT) {
            eraseList.push(value);
            newObj[key] = new Buffer(value);
          } else {
            newObj[key] = value;
          }
        }
        ret = newObj;
      }
      helpers.erase.apply(helpers, eraseList);
      return ret;
    }
  };

  for (key in nacl) {
    value = nacl[key];
    helpers.nacl[key] = value;
  }

  module.exports = helpers;

}).call(this);
