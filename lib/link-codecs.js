// Generated by CoffeeScript 1.8.0
(function() {
  var address, applyCloak, codecs, help, nacl;

  help = require('./helpers');

  address = require('./address');

  nacl = help.nacl;

  codecs = {};

  applyCloak = function(input, nonce, key) {
    var cloak, cloakByte, idx, output, _i, _len;
    cloak = help.blake(Buffer.concat([nonce, key], nonce.length + key.length), input.length);
    output = new Buffer(input.length);
    for (idx = _i = 0, _len = cloak.length; _i < _len; idx = ++_i) {
      cloakByte = cloak[idx];
      output[idx] = input[idx] ^ cloakByte;
    }
    return output;
  };

  codecs.id = {
    encode: function(_arg) {
      var ciphertext, cloakedKey, contents, identity, nonce, peer;
      contents = _arg.contents, identity = _arg.identity, peer = _arg.peer;
      if (!peer.publicKey) {
        throw new Error("cannot encode id packet without peer publicKey");
      }
      if (!Buffer.isBuffer(contents)) {
        throw new Error("contents must be a buffer");
      }
      nonce = help.randomBytes(nacl.box.nonceLength);
      cloakedKey = applyCloak(identity.publicKey, nonce, peer.publicKey);
      ciphertext = nacl(nacl.box, contents.slice(0), nonce, peer.publicKey, identity.secretKey);
      return Buffer.concat([nonce, cloakedKey, ciphertext]);
    },
    decode: function(_arg) {
      var ciphertext, cloakedKey, identity, nonce, packet, plaintext, senderPublicKey;
      packet = _arg.packet, identity = _arg.identity;
      if (packet.length <= nacl.box.nonceLength + nacl.box.publicKeyLength) {
        return false;
      }
      nonce = packet.slice(0, nacl.box.nonceLength);
      cloakedKey = packet.slice(nacl.box.nonceLength, nacl.box.nonceLength + nacl.box.publicKeyLength);
      ciphertext = packet.slice(nacl.box.nonceLength + nacl.box.publicKeyLength);
      senderPublicKey = applyCloak(cloakedKey, nonce, identity.publicKey);
      plaintext = nacl(nacl.box.open, ciphertext, nonce, senderPublicKey, identity.secretKey);
      if (plaintext === false) {
        return false;
      }
      return {
        contents: plaintext,
        author: senderPublicKey
      };
    }
  };

  module.exports = codecs;

}).call(this);
