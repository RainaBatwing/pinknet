// Generated by CoffeeScript 1.8.0
(function() {
  var address, applyCloak, codecs, help, nacl;

  help = require('./helpers');

  address = require('./address');

  nacl = help.nacl;

  codecs = {};

  applyCloak = function(input, nonce, key) {
    var cloak, cloakByte, idx, output, _i, _len;
    cloak = help.blake(Buffer.concat([nonce, key], nonce.length + key.length), input.length);
    output = new Buffer(input.length);
    for (idx = _i = 0, _len = cloak.length; _i < _len; idx = ++_i) {
      cloakByte = cloak[idx];
      output[idx] = input[idx] ^ cloakByte;
    }
    return output;
  };

  codecs.id = {
    encode: function(_arg) {
      var ciphertext, cloakedKey, data, network, nonce, to;
      data = _arg.data, network = _arg.network, to = _arg.to;
      to = address.parse(to);
      if (!to.publicKey) {
        throw new Error("cannot encode id packet without to.publicKey");
      }
      if (!Buffer.isBuffer(data)) {
        throw new Error("data must be a buffer");
      }
      nonce = help.randomBytes(nacl.box.nonceLength);
      cloakedKey = applyCloak(network.publicKey, nonce, to.publicKey);
      ciphertext = nacl(nacl.box, data.slice(0), nonce, to.publicKey, network.secretKey);
      return Buffer.concat([nonce, cloakedKey, ciphertext]);
    },
    decode: function(buffer, _arg) {
      var ciphertext, cloakedKey, err, network, nonce, plaintext, sender, senderPublicKey;
      network = _arg.network, sender = _arg.sender;
      if (buffer.length <= nacl.box.nonceLength + nacl.box.publicKeyLength) {
        return false;
      }
      nonce = buffer.slice(0, nacl.box.nonceLength);
      cloakedKey = buffer.slice(nacl.box.nonceLength, nacl.box.nonceLength + nacl.box.publicKeyLength);
      ciphertext = buffer.slice(nacl.box.nonceLength + nacl.box.publicKeyLength);
      senderPublicKey = applyCloak(cloakedKey, nonce, network.publicKey);
      plaintext = nacl(nacl.box.open, ciphertext, nonce, senderPublicKey, network.secretKey);
      if (plaintext === false) {
        return false;
      }
      try {
        if (sender.publicKey.toString('hex') !== senderPublicKey.toString('hex')) {
          sender = sender.copy();
          sender.publicKey = senderPublicKey;
        }
        return {
          data: plaintext,
          sender: sender
        };
      } catch (_error) {
        err = _error;
        return false;
      }
    }
  };

  codecs.compact = {
    encode: function(_arg) {
      var ciphertext, data, network, nonce, to, type;
      to = _arg.to, type = _arg.type, data = _arg.data, network = _arg.network;
      to = address.parse(to);
      nonce = help.randomBytes(nacl.box.nonceLength);
      if (!Buffer.isBuffer(data)) {
        throw new Error("data must be a buffer");
      }
      if (to.publicKey.length !== nacl.box.publicKeyLength) {
        throw new Error("to publicKey incorrect length");
      }
      if (network.secretKey.length !== nacl.box.secretKeyLength) {
        throw new Error("network secretKey incorrect length");
      }
      ciphertext = nacl(nacl.box, data.slice(0), nonce, to.publicKey, network.secretKey);
      return Buffer.concat([nonce, ciphertext]);
    },
    decode: function(buffer, _arg) {
      var ciphertext, network, nonce, plaintext, sender;
      network = _arg.network, sender = _arg.sender;
      if (!sender.publicKey) {
        return false;
      }
      nonce = buffer.slice(0, nacl.box.nonceLength);
      ciphertext = buffer.slice(nacl.box.nonceLength);
      plaintext = nacl(nacl.box.open, ciphertext, nonce, sender.publicKey, network.secretKey);
      if (!plaintext) {
        return false;
      }
      return {
        data: plaintext,
        sender: sender
      };
    }
  };

  module.exports = codecs;

}).call(this);
