// Generated by CoffeeScript 1.8.0
(function() {
  var PinkInvite, base58, blake2s, blakeDigest, msgpack, nacl, udp,
    __slice = [].slice;

  nacl = require('tweetnacl');

  base58 = require('bs58');

  msgpack = require('msgpack5')();

  blake2s = require('blake2s-js');

  udp = require('dgram');

  blakeDigest = function() {
    var args, data, digestor;
    data = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    digestor = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(blake2s, args, function(){});
    digestor.update(new Buffer(data));
    return digestor.digest();
  };

  PinkInvite = (function() {
    function PinkInvite(arg) {
      var key, _i, _len, _ref;
      if (typeof arg === 'string') {
        this._parse(arg);
      } else if (typeof arg === 'object') {
        _ref = ['address', 'port', 'publicKey'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          this[key] = arg[key];
        }
      }
    }

    PinkInvite.prototype._parse = function(inviteCode) {
      var data, datachunk, e, idx, inviteBytes;
      inviteBytes = base58.decode(inviteCode);
      datachunk = inviteBytes.slice(1);
      if (blakeDigest(datachunk, 1)[0] !== inviteBytes[0]) {
        throw new Error('Invite mistyped or incomplete');
      }
      try {
        data = msgpack.decode(datachunk);
      } catch (_error) {
        e = _error;
        throw new Error('Invite mistyped or incomplete');
      }
      if (!data.map) {
        throw new Error('Invite mistyped or incomplete');
      }
      if (data[0] !== 4) {
        throw new Error('Unknown invite type');
      }
      this.address = ((function() {
        var _i, _results;
        _results = [];
        for (idx = _i = 0; _i < 4; idx = ++_i) {
          _results.push(data[1].readUInt8(idx));
        }
        return _results;
      })()).join('.');
      this.port = data[1].readUInt16BE(4);
      return this.publicKey = data[2];
    };

    PinkInvite.prototype.toString = function() {
      var bytes, checksum, compactAddress, datachunk, digit, index, publicKey, _i, _len, _ref;
      publicKey = this.publicKey;
      if (typeof publicKey === 'string') {
        publicKey = base58.decode(publicKey);
      }
      compactAddress = new Buffer(6);
      _ref = this.address.split('.');
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        digit = _ref[index];
        compactAddress.writeUInt8(parseInt(digit), index);
      }
      compactAddress.writeUInt16BE(parseInt(this.port), 4);
      datachunk = msgpack.encode([4, compactAddress, new Buffer(publicKey)]).slice(0);
      checksum = blakeDigest(datachunk, 1);
      bytes = Buffer.concat([new Buffer(checksum), datachunk]);
      return base58.encode(bytes);
    };

    PinkInvite.prototype.inspect = function() {
      return "udp://" + (base58.encode(this.publicKey)) + "@" + this.address + ":" + this.port;
    };

    return PinkInvite;

  })();

  PinkInvite.verify = function(inviteCode) {
    var bytes, err;
    try {
      bytes = base58.decode(inviteCode);
    } catch (_error) {
      err = _error;
      return false;
    }
    return blakeDigest(bytes.slice(1), 1)[0] === bytes[0];
  };

  module.exports = {
    Invite: PinkInvite
  };

}).call(this);
