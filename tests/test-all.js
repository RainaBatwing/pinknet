// Generated by CoffeeScript 1.8.0
(function() {
  var assert, base58, mockNetwork1, mockNetwork2, nacl, pink, randomNetwork, suite, vows;

  pink = require('../pinknet');

  vows = require('vows');

  assert = require('assert');

  nacl = require('tweetnacl/nacl-fast');

  base58 = require('bs58');

  randomNetwork = function() {
    var keypair, net;
    keypair = nacl.box.keyPair();
    net = {
      secretKey: new Buffer(keypair.secretKey),
      publicKey: new Buffer(keypair.publicKey)
    };
    net.address = "udp://" + (base58.encode(net.publicKey.toJSON())) + "@4.3.2.1:5678/";
    return net;
  };

  suite = vows.describe("Pink Network Library");

  mockNetwork1 = randomNetwork();

  mockNetwork2 = randomNetwork();

  suite.addBatch({
    "pink.Address without pubkey": {
      topic: "udp://123.134.221.4:17892",
      "parses url": function(url) {
        return assert.notEqual(pink.Address.parse(url), false);
      },
      "encodes a buffer": function(url) {
        return assert.isTrue(Buffer.isBuffer(pink.Address.parse(url).toBuffer()));
      },
      "restores compact binary buffer": function(url) {
        return assert.equal(pink.Address.parse(pink.Address.parse(url).toBuffer()).toString(), url);
      }
    },
    "pink.Address with public key": {
      topic: "udp://" + (base58.encode(new Buffer(mockNetwork1.publicKey))) + "@123.134.221.4:17892",
      "restores compact binary buffer": function(url) {
        return assert.equal(pink.Address.parse(pink.Address.parse(url).toBuffer()).toString(), url);
      },
      "publicKey unpacks accurately": function(url) {
        var addr;
        addr = pink.Address.parse(pink.Address.parse(url).toBuffer());
        assert.notEqual(addr.publicKey, null);
        assert.equal(addr.publicKey.length, mockNetwork1.publicKey.length);
        return assert.equal(JSON.stringify(addr.publicKey.toJSON()), JSON.stringify((new Buffer(mockNetwork1.publicKey)).toJSON()));
      },
      "can encode buffer without a publicKey": function(url) {
        var addr;
        addr = pink.Address.parse(pink.Address.parse(url).toBuffer({
          includePublicKey: false
        }));
        return assert.equal(addr.publicKey, null);
      }
    },
    "pink.Invite": {
      topic: new pink.Invite({
        ip: "1.2.3.4",
        port: 5678,
        publicKey: mockNetwork1.publicKey
      }),
      "constructs something": function(invite) {
        assert.isString(invite.toString());
        return assert.isTrue(invite.toString().length !== 0);
      },
      "verifies": function(invite) {
        return assert.isTrue(pink.Invite.verify(invite.toString()));
      },
      "corrupted doesn't verify": function(invite) {
        return assert.isFalse(pink.Invite.verify(invite.toString() + "a"));
      },
      "parsing works": function(invite1) {
        var invite2;
        invite2 = pink.Invite.parse(invite1.toString());
        return assert.equal(invite1.address.toString(), invite2.address.toString());
      }
    },
    "pink.Pulse.encode()": {
      topic: pink.Pulse.encode({
        network: mockNetwork1,
        to: mockNetwork2.address,
        meta: {
          ein: "data dog"
        }
      }),
      "creates a buffer": function(output) {
        return assert.isTrue(Buffer.isBuffer(output));
      }
    }
  });

  suite.run();

}).call(this);
