// Generated by CoffeeScript 1.8.0
(function() {
  var assert, help, suite, vows;

  vows = require('vows');

  assert = require('assert');

  help = require('../lib/helpers');

  suite = vows.describe("Pink Helpers Library");

  suite.addBatch({
    "blake": {
      topic: help.blake('abc', 2),
      "correct output": function(output) {
        assert.equal(output[0], 0xD8);
        return assert.equal(output[1], 0xCE);
      }
    },
    "asByteArray with Buffer input": {
      topic: help.asByteArray(new Buffer([1, 2])),
      converts: function(out) {
        return assert.isTrue(out.constructor === Uint8Array);
      },
      correct: function(out) {
        return assert.equal(out[1], 2);
      },
      length: function(out) {
        return assert.equal(out.length, 2);
      }
    },
    "asByteArray with Uint8Array input": {
      topic: help.asByteArray(new Uint8Array([1, 2])),
      converts: function(out) {
        return assert.isTrue(out.constructor === Uint8Array);
      },
      correct: function(out) {
        return assert.equal(out[1], 2);
      },
      length: function(out) {
        return assert.equal(out.length, 2);
      }
    },
    "randomID": {
      topic: help.randomID(16),
      "is string": function(out) {
        return assert.equal(typeof out, 'string');
      },
      "contains something": function(out) {
        return assert.isTrue(out.length > 0);
      },
      "is unique": function(out) {
        return assert.notEqual(out, help.randomID(16));
      }
    },
    "uniqueIndex": {
      topic: function() {
        var i, obj, _i;
        obj = {};
        for (i = _i = 0; _i < 500; i = ++_i) {
          obj[i.toString(36)] = 'used';
        }
        return obj;
      },
      "unused": function(obj) {
        return assert.equal(obj[help.uniqueIndex(obj)], void 0);
      },
      "returns string": function(obj) {
        return assert.equal(typeof (help.uniqueIndex(obj)), 'string');
      },
      "ouputs something": function(obj) {
        return assert.isTrue(help.uniqueIndex(obj).length > 0);
      }
    },
    "erase": {
      topic: [1, 2],
      "works": function(test) {
        var arr, buf;
        arr = new Uint8Array(test);
        buf = new Buffer(test);
        assert.equal(arr[0], 1);
        assert.equal(arr[1], 2);
        assert.equal(buf[0], 1);
        assert.equal(buf[1], 2);
        help.erase(arr, buf);
        assert.equal(arr[0], 0);
        assert.equal(arr[1], 0);
        assert.equal(buf[0], 0);
        return assert.equal(buf[1], 0);
      }
    },
    "nacl.randomBytes": {
      topic: help.nacl(help.nacl.randomBytes, 5),
      "returned buffer": function(ret) {
        return assert.isTrue(Buffer.isBuffer(ret));
      },
      "correct length": function(ret) {
        return assert.equal(ret.length, 5);
      }
    },
    "nacl.util.decodeBase64": {
      topic: help.nacl(help.nacl.util.decodeBase64, '44GL44KP44GE44GE'),
      "returns buffer": function(ret) {
        return assert.isTrue(Buffer.isBuffer(ret));
      },
      "is correct": function(ret) {
        return assert.equal(ret.toString(), "かわいい");
      }
    },
    "nacl.secretbox.open": {
      topic: function() {
        var box, key, nonce;
        key = new Buffer('Bkiuwce/zjTus6IBqb5z5ZaiTbnHNLqZgvoCy8sInhA=', 'base64');
        nonce = new Buffer('LGs1eABctUsXLFlbmQ4gZOXT5HlegqW4', 'base64');
        box = new Buffer('43q6DOmCaVm0ex5C8gnGySt0lvFQaVE5', 'base64');
        return help.nacl(help.nacl.secretbox.open, box, nonce, key);
      },
      "returns buffer": function(ret) {
        return assert.isTrue(Buffer.isBuffer(ret));
      },
      "correct length": function(ret) {
        return assert.equal(ret.length, 8);
      }
    }
  });

  suite.run();

}).call(this);
